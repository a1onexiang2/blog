[Home](../../README.md)  

# Standard  

## Https  
HTTPS 由两部分组成：HTTP、SSL/TLS，即在 HTTP 上又加了一层处理加密信息的模块。使用 HTTPS 协议之后在网络上传输的数据是加密的密文，即便被拦截，没有密钥进行解密的话也就是一串乱码。端口号是 443。  

#### SSL/TLS  
SSL 和 TLS 是不同时期的协议叫法，一般都叫 SSL 证书。TLS 是在 SSL 基础上发展的新版本，有时候会统称该协议为 SSL。  
SSL 为了解决三大风险设计：  
1. 窃听风险（eavesdropping）  
   所有信息都是加密传播，第三方无法窃听。  
2. 篡改风险（tampering）  
   具有校验机制，一旦被篡改，通信双方会立刻发现。  
3. 冒充风险（pretending）  
   配备身份证书，防止身份被冒充。  

#### Https 通讯流程  
HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构（CA）颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。一次 Https 通讯的大致流程如下：  
![image](https://user-images.githubusercontent.com/8423120/47548147-9e26d900-d92a-11e8-9f11-d5e790d1ff57.png)    
1. 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。**注意：客户端还会附加一个随机数，这里记为 A。**  
2. 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。**注意：这里服务器同样会附加一个随机数，发给客户端，这里记为 B。**  
3. 接着服务端将自己的公钥等信息发给 CA 申请证书并数字签名，CA 用自己的私钥进行加密，然后将其都发还给服务器，服务器再将其发给客户端。  
4. 客户端尝试用自己系统内置的所有 CA 的公钥对服务端发过来的公钥进行解密，如果所有 CA 的公钥都无法解密的话，说明服务端发过来的证书是不被信任的，弹出警告；如果用自己内置的某个 CA 公钥对服务端发过来的公钥进行解密成功，说明服务端发过来的证书是正常的，然后对服务端的证书进行有效期、机构信息等进行验证，如果验证不通过（例如过期），则弹出警告。  
5. 接着，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用随机生成的 Pre-master secret 的随机密码串。该报文使用从证书中解密获得的公钥进行加密（其实就是服务器的公钥）。当其生成了 Pre-master secret 之后，会结合原来的 A、B，用 DH 算法计算出一个 master secret，紧接着根据这个 master secret 推导出 hash secret 和 session secret。  
6. 客户端继续发送 Change Cipher Spec 报文。用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。发送 finish 报文。  
7. 服务器接收到客户端的请求之后，使用私钥解密报文，把 Pre-master secret 取出来。接着，服务器同样发送 Change Cipher Spec 报文和 finish 报文。当服务器解密获得了 Pre-master secret 之后，会结合原来的 A、B，用 DH 算法计算出一个 master secret，紧接着根据这个 master secret 推导出 hash secret 和 session secret。  
8. 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。  
9. 接下来双方使用对称加密算法进行加密，用 hash secret 对 HTTP 报文做一次运算生成一个 MAC（相当于摘要），附在 HTTP 报文的后面，然后用 session-secret 加密所有数据（HTTP + MAC），然后发送。接收方则先用 session-secret 解密数据，然后得到 HTTP + MAC，再用相同的算法计算出自己的 MAC，如果两个 MAC 相等，证明数据没有被篡改。  

[Home](../../README.md)   