[Home](../../README.md)

# Java

## Data Structure

#### 数组（Array）
数组是一种储存容器，它能够顺序储存相同类型的多个数据，并且可以把其中的元素编号并索引，通过索引可以获取对应位置的元素。
Java 中的 Array 不可扩容，在声明时需要直接定义长度。ArrayList、Vector 更符合宏观意义上数组的定义。它们底层都实现了 List 接口，异同如下：

属性 | ArrayList | Vector
-- | -- | --
是否线程安全 | 不安全 | 安全
持续序列化 | 支持 | 不支持
扩容方式 | new = raw * 3 / 2 + 1 | new = raw + (k > 0 ? k : raw)
Enumeration | 不支持 | 支持通过 Enumeration 遍历

数组有以下特性：
- 数组在查询上直接通过索引获取元素，复杂度是 *O*(1)，是极为高效的。
- 数组在插入时分为两种情况，在队尾插入或在非队尾插入，不过无论哪种情况，都需要先判断数组当前容量，若容量足够则可以直接执行插入操作，若容量不足，需要先对数组进行扩容，然后再执行插入操作。在执行插入时，需要将插入位置至队尾的元素向后移动后再插入元素。在队尾插入时，复杂度是 *O*(1)，平均复杂度是 *O*(n)。
- 数组在删除时类似插入操作，删除元素后，需要将删除位置至队尾位置的元素向前移动。删除队尾元素时，复杂度是 *O*(1)，平均复杂度是 *O*(n)。

#### 链表（LinkedList）
链表是一种有递归思想的储存容器。每一个链表元素由两部分组成：存储数据元素的数据域，存储下一个结点地址的指针域。
链表根据具体实现可以分为：单向链表、双向列表。双向链表除了储存下一个结点地址以外，还会储存上一个结点的地址。Java 中链表的实现有 LinkedList，它底层实现了 List 接口，是双向链表。

链表有以下特性：
- 链表在查询上需要通过遍历元素来实现，复杂度是 *O*(n)。双向链表可以根据查询位置和链表长度来决定从头部还是尾部开始遍历，复杂度是 *O*(n/2)。
- 链表在插入时，如果提供的位置是索引位置，则需要执行查询操作找到该位置，复杂度是 *O*(n)，然后执行链表元素插入操作，复杂度是 *O*(1)，整个操作的复杂度是 *O*(n)。如果需要在某结点之后插入并提供了该结点的引用，则可以直接执行元素插入操作，复杂度是 *O*(1)。
- 链表在删除时类似插入操作，如果提供的位置是具体索引位置，则需要执行查询操作找到该位置，复杂度是 *O*(n)，然后执行链表元素删除操作，复杂度是 *O*(1)，整个操作的复杂度是 *O*(n)。如果需要删除某结点并提供了该结点的父结点的引用，则可以直接执行元素删除操作，复杂度是 *O*(1)。

链表查询的复杂度虽然是 *O*(n)，但与数组移位的 *O*(n) 比起来快很多。在频繁插入或删除元素时，链表是更优选择。

#### 树（Tree）
树是数据元素之间具有次层关系的非线性的抽象数据结构。树中的每一个元素都称之为结点，每一个结点最多只有一个父结点，并可以有若干个子结点，没有父结点的结点称之为根结点，没有子结点的结点称之为叶子结点。
常见的树有：二叉树、二叉查找数（有序的二叉树）、AVL 树（带平衡条件的二叉查找树）、红黑树（带着色性质的 AVL 树）、B 树（多叉查找树）等等。值得一提的是霍夫曼树，它基于结点的权重排序将结点组合成树，最终形成霍夫曼树，霍夫曼编码是基于霍夫曼树的一种数据压缩算法。
Java 中树的实现有 TreeMap、TreeSet。TreeMap 是一个有序的键-值集合，内部基于红黑树实现，TreeSet 基于 TreeMap 实现。树的查找、插入、删除的复杂度是 *O*(logN)。

#### 队列（Queue）
队列是一种采用先进先出 (FIFO) 策略的抽象数据结构。它依赖于其它的储存容器来存储队列内的元素。
Java 中队列的实现有 PriorityQueue、PriorityBlockingQueue、ArrayBlockingQueue、ArrayDeque、LinkedList。它们底层都实现了 Queue 接口。其中 PriorityQueue、PriorityBlockingQueue 内部采用了优先级策略，优先级更高（语义上的高，指最优先）的会在队列的最前端，其内部会保留两个指针分别指向队列当前头部和尾部；Deque 是双向队列接口，ArrayDeque、LinkedList 都实现了 Deque 接口，可以用作双向队列。队列在使用时由于存在大量的入队、出队操作，一般会使用链表作为储存容器。
无法根据位置获取队列中的元素。

#### 栈（Stack）
栈是一种采用后进先出 (LIFO) 策略的抽象数据结构。它依赖于其它的储存容器来存储队列内的元素。
Java 中栈的实现有 Stack、ArrayDeque、LinkedList。Stack 底层基于 Vector，ArrayDeque、LinkedList 底层都实现了 Deque 接口。它们在定义上是双向队列，但在实际运用中更接近于栈的概念。栈在使用时由于存在大量的压栈、出栈操作，一般会使用链表作为储存容器。
无法根据位置获取栈中的元素。

#### 堆（Heap）
堆也被称为优先队列（Priority Queue）。
堆可以看成一个二叉树，所以可以考虑使用二叉树的表示方法来表示堆。同时因为堆中元素按照一定的优先顺序排列，因此可以使用更简单的方法 “数组” 来表示，这样可以节省子节点指针空间，并且可以快速访问每个节点。堆的数组表示其实就是堆层级遍历的结果。

#### 哈希表（Hash）
哈希表就是一种以键-值存储数据的抽象数据结构，根据键值即可查找到其对应的值。
如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。如果键值是更复杂的类型，使用时需要把键值映射成索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况，这时候需要处理冲突。处理冲突一般有拉链法和线性探测法。
拉链法即把每个元素储存为一个链表，链表中储存所有映射成该索引的键值对来解决索引冲突。线性探测法指当发生索引冲突时，依次检索之后的索引，并在第一个空的位置储存该冲突元素。
Java 中哈希表的实现有 HashMap、HashTable、ConcurrentHashMap。HashTable 和 HashMap 采用相同的存储机制，但 HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都是 synchronized，而 ConcurrentHashMap 内部多了一个 Segment 结构，使用 Lock 对象来进行线程同步，并实现了分段锁机制。HashMap 支持 key 或 value 为 `null`，HashTable、ConcurrentHashMap 的 key 和 value 都不可为 `null`。

#### 图（Graph）
图是一种复杂的非线性结构。在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。
图可以根据自身特点分为无向图和有向图，无权图和有权图。

[Home](../../README.md)
