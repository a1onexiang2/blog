[Home](../../README.md)

# Java

## GC
介于 JVM 自动内存分配机制的帮助下，不再需要为每一个 new 操作去写配对的 delete/free 代码。Java 的内存分配管理是一种托管的方式，托管于 JVM。Java 代码经过编译会变成字节码由 JVM 解释执行。
GC 机制主要完成 3 件事：确定哪些内存需要回收、确定什么时候需要执行 GC、如何执行 GC。

#### 内存如何分配
![image](https://user-images.githubusercontent.com/8423120/46062354-25522700-c19c-11e8-8bbb-6324c61b00b3.png)
- **程序计数器（Program Counter Register）**<br>
是一块较小的内存空间，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。
每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。
如果程序执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个 native方法，则计数器的值为 undefined。
由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有 JVM 内存区域中唯一一个不会抛出 OutOfMemoryError 的区域。
- **虚拟机栈（Java Virtual Machine Stacks）**<br>
一个线程的每个方法在执行的同时，都会创建一个栈帧（Stack Frame），栈帧中存储的有局部变量表、操作栈、动态链接、方法出口等，当方法被调用时，栈帧在 JVM 栈中入栈，每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。
局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。
虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出 StatckOverFlowError（栈溢出），不过多数 JVM 都允许动态扩展虚拟机栈的大小 (有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时会抛出 OutOfMemoryError（内存溢出）。
- **本地方法栈（Native Method Stacks）**<br>
本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行 Java 方法的，而本地方法栈是用来执行 native 方法的。
在很多虚拟机中（如 Sun 的 JDK 默认的 HotSpot 虚拟机），会将本地方法栈与虚拟机栈放在一起使用。
本地方法栈也是线程私有的。
- **堆区（Heap）**<br>
在 JVM 管理的内存中，堆区是最大的一块，也是 GC 机制所管理的主要内存区域。
堆区由所有线程共享，在虚拟机启动时创建。
堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。
根据 JVM 规范规定，堆内存需要在逻辑上是连续的（在物理上不需要）。在实现时，可以是固定大小，也可以是可扩展的。目前主流的虚拟机都是可扩展的。
如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出 OutOfMemoryError:Java heap space。
- **方法区（Method Area）**<br>
在 JVM 规范中，将方法区作为堆的一个逻辑部分来对待，但事实上方法区并不是堆（Non-Heap）。
有些说法把方法区定义为 “永久代” ，因为之前的 HotSpot JVM 的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。除 HotSpot 之外的多数虚拟机，并不将方法区当做永久代，HotSpot 本身也计划取消永久代。
方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final 常量、静态变量、编译器即时编译的代码等。
方法区在物理上不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般而言方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一，但这也不代表着在方法区上完全没有垃圾收集，其进行的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑。
在内存不足时会抛出 OutOfMemoryError:PermGen space 异常。
运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如 String 类的 intern() 方法，作用是 String 维护了一个常量池，如果调用的字符 “abc” 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。
- **直接内存（Direct Memory）**<br>
直接内存并不是 JVM 管理的内存，是 JVM 以外的机器内存。JDK 中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由 C 语言实现的 native 函数库分配在直接内存中，用存储在 JVM 堆中的 DirectByteBuffer 来引用。
由于直接内存收到本机器内存的限制，所以也可能抛出 OutOfMemoryError 异常。

#### 判断死亡
JVM 一般采用 GC Roots 方法，只要从任何一个 GC Roots 的对象可达，就是不被回收的对象。在该算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：
1. 如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 `finalize()` 方法。当对象没有覆盖 `finalize()` 方法，或 `finalize()` 方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。
2. 如果该对象被判定为有必要执行 `finalize()` 方法，那么这个对象将会被放置在一个名为 F-Queue 队列中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行 `finalize()` 方法。`finalize()` 方法是对象逃脱死亡命运的最后一次机会（因为一个对象的 `finalize()` 方法最多只会被系统自动调用一次），稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记。如果要在 `finalize()` 方法中成功拯救自己，只要在 `finalize()` 方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。

#### 内存分配与 GC 机制
这里所说的内存分配，主要指的是在堆上的分配。Java 内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代、年老代、永久代（即方法区）。
![image](https://user-images.githubusercontent.com/8423120/46071566-e1b6e780-c1b2-11e8-86b3-74b92999e914.png)
![image](https://user-images.githubusercontent.com/8423120/46071568-e4194180-c1b2-11e8-963f-984d58f5f9fb.png)
- **年轻代（Young Generation）**<br>
年轻代可以分为 3 个区域：Eden 区（用来表示内存首次分配的区域）和两个存活区（Survivor 0 、Survivor 1）。
绝大多数刚创建的对象会被分配在 Eden 区，其中的大多数对象很快就会消亡。Eden 区是连续的内存空间，因此在其上分配内存极快。存活区至少一个是空的。
年轻代使用了停止 & 复制（Stop-and-copy）清理法。
当 Eden 区满的时候，会执行 Minor GC（也叫 Young GC），但这并不代表年轻代内存不足。Minor GC 会清理 Eden 区内消亡的对象，并将存活的对象复制到一个存活区（Suvivor 0）内。当再次触发 Minor GC 时，会将 Eden 区存活的对象复制到另一个存活区（Suvivor 1）内，并将原来存活区（Suvivor 0）仍然存活的对象也复制过来。之后循环往复。
当对象在存活区间切换了若干次（HotSpot 虚拟机默认 15 次，用 `-XX:MaxTenuringThreshold` 控制）后，仍然存活的对象将被复制到年老代。
由于绝大部分的对象都是短命的，甚至存活不到 Survivor 中，所以，Eden 区与 Survivor 的比例较大，HotSpot 默认是 8:1，即分别占新生代的 80%，10%，10%。如果一次回收中，年轻代中存活下来的内存超过了 10%，则需要将一部分对象分配到老年代。
可以用 `-XX:SurvivorRatio` 参数来配置 Eden 区与 Survivor 区的容量比，默认是 8，代表 Eden：Survivor1：Survivor2 = 8:1:1。
- **年老代（Old Generation）**<br>
对象如果在年轻代存活了足够长的时间而没有被清理掉，则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的 GC 次数也比年轻代少。
当年老代内存不足时，将执行 Major GC（也叫 Full GC）。
可以使用 `-XX:+UseAdaptiveSizePolicy` 开关来控制是否采用动态控制策略，如果动态控制，则动态调整 Java 堆中各个区域的大小以及进入年老代的年龄。
如果对象比较大，年轻代空间不足，则会直接分配到年老代上。大对象可能触发提前 GC，应少用，更应避免使用短命的大对象。可以用 `-XX:PretenureSizeThreshold` 来控制直接分配到年老代的对象大小阈值，大于这个值的对象会直接分配在年老代上。
老年代用的算法是标记-整理算法，即标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。
在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余的连续空间大小。如果年老代的连续空间不够，会直接触发一次 Full GC，否则会触发 Minor GC。
可能存在年老代对象引用新生代对象的情况，如果需要执行 Minor GC，可能需要查询整个年老代以确定是否可以清理回收，这显然是低效的。解决的方法是在年老代中维护一个 512 byte 的块 “card table” ，所有年老代对象引用新生代对象的记录都记录在这里。在调用 Minor GC 时，只要查询这里即可，不用再去查询全部年老代，因此性能大大提高。
- **永久代（Permanent Generation）**<br>
永久代的回收有两种：常量池中的常量，无用的类信息。
常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证：类的所有实例都已经被回收、加载类的 ClassLoader 已经被回收、类对象的 Class 对象没有被引用（即没有通过反射引用该类的地方）

#### GC
按执行机制划分， Java 有四种类型的垃圾回收器：串行垃圾回收器、并行垃圾回收器、并发标记扫描垃圾回收器、G1 垃圾回收器。每种类型都有自己的优势与劣势，在很大程度上有所不同并且可以为我们提供完全不同的应用程序性能。可以通过向 JVM 传递参数选择垃圾回收器类型。
- **串行垃圾回收器（Serial Garbage Collector）**<br>
串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作。
它最适合的是简单的命令行程序（单 CPU、新生代空间较小及对暂停时间要求不是非常高的应用）。是 client 级别默认的 GC 方式。
通过 JVM 参数 `-XX:+UseSerialGC` 可以使用串行垃圾回收器。
- **并行垃圾回收器（Parallel Garbage Collector）**<br>
并行垃圾回收器是 JVM 的默认垃圾回收器。它使用多线程进行垃圾回收，但当执行垃圾回收时也会冻结所有的应用程序线程。
适用于多 CPU、对暂停时间要求较短的应用上，是 server 级别默认采用的 GC 方式。
可用 `-XX:+UseParallelGC` 来强制指定，用 `-XX:ParallelGCThreads=x` 来指定线程数。
- **并发标记扫描垃圾回收器（CMS Garbage Collector）**<br>
并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。
1. 当标记的引用对象在 Tenured 区域；
2. 在进行垃圾回收的时候，堆内存的数据被并发的改变。
相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的 CPU 来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的 CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。
通过 JVM 参数 `-XX:+USeParNewGC` 打开并发标记扫描垃圾回收器。
- **G1 垃圾回收器（G1 Garbage Collector）**<br>
G1 垃圾回收器能充分利用多 CPU、多核环境，是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。
G1 垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并发地对其进行垃圾回收，也可以在回收内存之后对剩余的堆内存空间进行压缩。
通过 JVM 参数 `–XX:+UseG1GC` 使用 G1 垃圾回收器。

#### 相关方法
- **`System.gc()`**<br>
使用 System.gc() 可以不管 JVM 使用的是哪一种垃圾回收的算法，都可以请求 Java 的垃圾回收。调用 `System.gc()` 也仅仅是一个请求（建议）。JVM 接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。
- **`Object.finalize()`**<br>
存在着垃圾回收器不能处理的特殊情况，例如：
1. 分配内存时可能采用了类似 C 语言的做法，例如通过 native method 调用了 C/C++ 方法 `malloc()` 函数系列来分配存储空间，则只能通过 `free()` 函数来释放内存，在 `finalize()` 中可以用做一些处理来释放这些 “特殊” 的内存空间。
2. 打开的文件资源，这些资源不属于垃圾回收器的回收范围。
这时就需要用到 `finalize()` 方法，换言之，`finalize()` 的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。
一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用 `finalize()` 方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。
当 `finalize()` 方法被调用时，JVM 会释放该线程上的所有同步锁。

#### 触发 GC 的条件
以下情况会触发 GC 运行：
1. 当应用程序空闲时，即没有应用线程在运行时，GC 会被调用。因为 GC 在优先级最低的线程中进行，所以当应用忙时，GC 线程就不会被调用。
2. Java 堆内存不足时，GC 会被调用。当应用线程创建新对象且内存空间不足时，JVM 就会强制地调用 GC 线程。若 GC 一次之后仍不能满足内存分配的要求，JVM 会再进行两次 GC 作进一步的尝试，若仍无法满足要求，JVM 将会抛出 OutOfMemoryError。
3. 在编译过程中作为一种优化技术，Java 编译器能选择给实例赋 null 值，从而标记实例为可回收。

[Home](../../README.md)