[Home](../../README.md)

# Java

## I/O

#### I/O 模型
I/O 模型可以从同步或异步、阻塞或非阻塞两个维度来分类。
需要注意的是，阻塞并不等价于同步，而非阻塞并非等价于异步。
同步和异步着重点在于多个任务执行过程中，后发起的任务是否必须等先发起的任务完成之后再进行。而不管先发起的任务请求是阻塞等待完成，还是立即返回通过循环等待请求成功。
而阻塞和非阻塞重点在于请求的方法是否立即返回（或者说是否在条件不满足时被阻塞）。
- **同步或异步\*\*\r\r
所谓同步，指每个请求必须逐个地被处理，一个请求的处理会导致整个流程的暂时等待，这些事件无法并发地执行。用户线程发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行。
所谓异步，指多个请求可以并发地执行，一个请求或者任务的执行不会导致整个流程的暂时等待。用户线程发起 I/O 请求后仍然继续执行，当内核 I/O 操作完成后会通知用户线程，或者调用用户线程注册的回调函数。
- **阻塞或非阻塞\*\*\r\r
所谓阻塞，指某个请求发出后，由于该请求操作需要的条件不满足，请求操作一直阻塞，不会返回，直到条件满足。
所谓非阻塞，指请求发出后，若该请求需要的条件不满足，则立即返回一个标志信息告知条件不满足，而不会一直等待。一般需要通过循环判断请求条件是否满足来获取请求结果。

#### Java I/O
![image](https://user-images.githubusercontent.com/8423120/46002839-b0bab200-c0e1-11e8-8f61-814d9fa6a251.png)

#### Okio
Okio 补充了 java.io 和 java.nio 的内容，使得数据访问、存储和处理更加便捷。它的主要功能都被封装在 ByteString 和 Buffer 这两个类中，整个库也是围绕这两个类展开。
- **ByteString\*\*\r\r
ByteString 代表一个 immutable 字节序列。对于字符数据来说，String 是非常基础的，但在二进制数据的处理中，则没有与之对应的存在，ByteString 应运而生。它提供了对串操作所需要的各种 API，例如子串、判等、查找等，也能把二进制数据编解码为十六进制（hex），base64 和 UTF-8 格式。
- **Source、Sink\*\*\r\r
Okio 吸收了 java.io 一个非常优雅的设计：流（stream），流可以一层一层套起来，不断扩充能力，最终完成像加密和压缩这样复杂的操作。Okio 有自己的流类型，那就是 Source 和 Sink，它们和 InputStream 与 OutputStream 类似，前者为输入流，后者为输出流。
但它们还有以下特性：
    - 超时机制，所有的流都有超时机制。
    - Source 和 Sink 的 API 非常简洁，为了应对更复杂的需求，Okio 还提供了 BufferedSource 和 BufferedSink 接口，便于使用（按照任意类型进行读写，BufferedSource 还能进行查找和判等）。
    - 不再区分字节流和字符流，它们都是数据，可以按照任意类型去读写。
    - 便于测试，Buffer 同时实现了 BufferedSource 和 BufferedSink 接口，便于测试。

Source 和 InputStream 互相操作，可以把它们等同对待，同理 Sink 和 OutputStream 也可以等同对待。
- **Buffer\*\*\r\r
Buffer 集 BufferedSource 和 BufferedSink 的功能于一身，提供了访问数据缓冲区所需要的一切 API。
Buffer 是一个可变的字节序列，就像 ArrayList 一样。使用时只管从它的头部读取数据，往它的尾部写入数据，无需考虑容量、大小、位置等其他因素。
![image](https://user-images.githubusercontent.com/8423120/46715501-d2e03280-cc92-11e8-9aca-ed7b1924f941.png)


[Home](../../README.md)