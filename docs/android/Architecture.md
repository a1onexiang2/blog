[Home](../../README.md)

# Android

## Architecture
Android 中常见的架构有 MVC、MVP、MVVM。
在架构模式的选用时，开发者往往没有太多的发言权，主要因为平台本身往往对应用层有着自己的设计，在开发客户端或者前端应用时，只需要遵循平台固有的设计就可以完成应用的开发；不过，在有些时候，由于工程变得庞大、业务逻辑变得异常复杂，也可以考虑在原有的架构之上实现一个新的架构以满足工程上的需要。
各种架构模式的作用就是分离关注，将属于不同模块的功能分散到合适的位置中，同时尽量降低各个模块的相互依赖并且减少需要联系的胶水代码。

#### MVC
![image](https://user-images.githubusercontent.com/8423120/46779936-a2f56580-cd4c-11e8-84f2-0f579155f2b6.png)
MVC 架构模式的三个组成部分：Model、View 和 Controller 中最重要的就是控制器，它承担了整个架构中的大部分业务逻辑，同时在用户请求到达或者事件发生时都会首先通知控制器并由它来决定如何响应这次请求或者事件。
在绝大多数的 MVC 架构模式中，模型都不会主动向视图或者控制器推送消息；模型都是被动的，它只存储整个应用中的数据，而信息的获取和更新都是由控制器来驱动的。当模型中的数据发生变化时，却需要通过一些方式通知对应的视图进行更新，在这种情况下其实也不需要模型主动将数据变化的消息推送给视图；因为所有对于模型层的改变都是由用户的操作导致的，而用户的操作都是通过控制器来处理的，所以只需要在控制器改变模型时，将更新的信息发送给视图就可以了；当然，我们也可以通过观察者模式向未知的观察者发送通知，以保证状态在不同模块之间能够保持同步。

#### MVP
MVP 架构模式是 MVC 的一个变种，MVC 与 MVP 之间的区别其实并不明显，最大的区别是 Presenter 对 View 与 Model 之间进行了解耦，它们彼此都对对方一无所知，都通过 Presenter 进行通信。
Presenter 可以理解为松散的控制器，其中包含了视图的 UI 业务逻辑，所有从视图发出的事件，都会通过代理给 Presenter 进行处理；同时，Presenter 也通过视图暴露的接口与其进行通信。
目前常见的 MVP 架构模式其实都是下列架构的变种：
- **被动视图（Passive View）**<br>
视图成为了完全被动的并且不再根据模型来更新视图本身的内容，也就是说，不同于 MVC 中的依赖关系；在被动视图中，视图层对于模型层没有任何的依赖：
![image](https://user-images.githubusercontent.com/8423120/46779659-5fe6c280-cd4b-11e8-8443-ada3ee83e4c8.png)
因为视图层不依赖与其他任何层级也就最大化了视图层的可测试性，同时也将视图层和模型层进行了合理的分离，两者不再相互依赖。
在被动式图中，视图层是被动的，它本身不会改变自己的任何的状态，所有的状态都是通过 Presenter 来间接改变的。
被动视图的通信方式：
![image](https://user-images.githubusercontent.com/8423120/46779503-b69fcc80-cd4a-11e8-89b7-c5b3847e5546.png)
    1. 当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理。
    2. 被动的视图向外界暴露接口，当需要更新视图时 Presenter 通过视图暴露的接口更新视图的内容。
    3. Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息。
    4. 当模型层改变时，可以将改变的信息发送给观察者 Presenter。
- **监督控制器（Supervising Controller）**<br>
监督控制器中，视图层接管了一部分视图逻辑，主要内容就是同步简单的视图和模型的状态；而监督控制器就需要负责响应用户的输入以及一部分更加复杂的视图、模型状态同步工作。
监督控制器的通信方式：
![image](https://user-images.githubusercontent.com/8423120/46779799-fdda8d00-cd4b-11e8-8a63-dcb7785bb4b1.png)
视图通过声明式的语法与模型中的简单属性进行绑定，当模型发生改变时，会通知其观察者视图作出相应的更新。
监督控制器中的视图和模型层之间增加了两者之间的耦合，也就增加了整个架构的复杂性，通过这种方式能够减轻监督控制器的负担，减少其中简单的代码，将一部分逻辑交由视图进行处理；这样也就导致了视图同时可以被 Presenter 和数据绑定两种方式更新，相比于被动视图，监督控制器的方式也降低了视图的可测试性和封装性。

#### MVVM
PM 模式中创建了一个视图的抽象，叫做 Presentation Model，而视图也成为了这个模型的渲染结果。MVVM 与 Martin Fowler 所说的 PM 模式其实是完全相同的，MVVM 由三个部分组成，也就是 Model、View 和 ViewModel；其中视图模型（ViewModel）其实就是 PM 模式中的 Presentation Model，在 MVVM 中叫做视图模型。除了 Model、View 和 ViewModel 这三个部分，在 MVVM 的实现中，还引入了隐式的一个 Binder 层，而声明式的数据和命令的绑定在 MVVM 模式中就是通过它完成的。
![image](https://user-images.githubusercontent.com/8423120/46780079-75f58280-cd4d-11e8-83fd-ad437b0cfda5.png)
![image](https://user-images.githubusercontent.com/8423120/46780168-cff64800-cd4d-11e8-833f-8690cf4ba3c0.png)
![image](https://user-images.githubusercontent.com/8423120/46780178-e00e2780-cd4d-11e8-9249-42fd476e8fb8.png)


[Home](../../README.md)